commit 18d8017f18287708ca7c636084f0e00a633f2be7
Author: Palkiayp <87257272+AnthonyPark465@users.noreply.github.com>
Date:   Tue Dec 2 22:20:59 2025 +0800

    Add files via upload

diff --git a/app.py b/app.py
index 67973c3..3af31b6 100644
--- a/app.py
+++ b/app.py
@@ -1,25 +1,234 @@
-from flask import Flask, render_template, request, jsonify
+from flask import (
+    Flask,
+    render_template,
+    request,
+    jsonify,
+    session,
+    send_file,
+    make_response,
+)
 import cv2
 import numpy as np
+import sqlite3
+import os
+import random
+import datetime
+import uuid
+import json
 
 app = Flask(__name__)
+app.secret_key = "super_secret_random_key_for_session_encryption"
 
-@app.route('/')
+DB_NAME = "quiz_stats.db"
+VIDEO_FOLDER = "videos"
+PROMPT_FILE = "prompts.json"
+
+if not os.path.exists(VIDEO_FOLDER):
+    os.makedirs(VIDEO_FOLDER)
+
+try:
+    with open(PROMPT_FILE, "r") as f:
+        PROMPTS = json.load(f)
+except FileNotFoundError:
+    print(f"ERROR: {PROMPT_FILE} not found. Quiz will not function correctly.")
+    PROMPTS = []
+except json.JSONDecodeError:
+    print(f"ERROR: Could not parse {PROMPT_FILE}. Check JSON formatting.")
+    PROMPTS = []
+
+
+def get_db():
+    conn = sqlite3.connect(DB_NAME)
+    conn.row_factory = sqlite3.Row
+    return conn
+
+
+def init_db():
+    conn = get_db()
+    c = conn.cursor()
+    c.execute(
+        """
+        CREATE TABLE IF NOT EXISTS attempts (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            ip_address TEXT,
+            question_index INTEGER, 
+            is_correct BOOLEAN,
+            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
+        )
+    """
+    )
+    conn.commit()
+    conn.close()
+
+
+init_db()
+
+
+def get_video_filename(prompt_text):
+    clean_name = (
+        prompt_text.replace("?", "").replace(".", "").replace(",", "").replace("’", "").replace(" ", "_")
+    )
+    return f"{clean_name}.mp4"
+
+
+@app.route("/")
 def index():
     return render_template("index.html")
 
-@app.route('/avg_colour', methods=['POST'])
+
+@app.route("/get_question", methods=["GET"])
+def get_question():
+    user_ip = request.remote_addr
+
+    if not PROMPTS:
+        return jsonify({"error": "Quiz data not loaded."}), 500
+
+    conn = get_db()
+    cursor = conn.cursor()
+    twenty_four_hours_ago = datetime.datetime.now() - datetime.timedelta(hours=24)
+
+    cursor.execute(
+        """
+        SELECT question_index, is_correct 
+        FROM attempts 
+        WHERE ip_address = ? AND timestamp > ?
+    """,
+        (user_ip, twenty_four_hours_ago),
+    )
+    rows = cursor.fetchall()
+    conn.close()
+
+    weights = [1.0] * len(PROMPTS)
+    for row in rows:
+        idx = row["question_index"]
+        if 0 <= idx < len(weights):
+            if not row["is_correct"]:
+                weights[idx] += 3.0
+            else:
+                weights[idx] = max(0.1, weights[idx] - 0.5)
+
+    selected_internal_index = random.choices(range(len(PROMPTS)), weights=weights, k=1)[
+        0
+    ]
+
+    question_token = str(uuid.uuid4())
+
+    session["current_question_token"] = question_token
+    session[question_token] = selected_internal_index
+
+    total_attempts = len(rows)
+    correct_attempts = sum(1 for r in rows if r["is_correct"])
+
+    return jsonify(
+        {
+            "question_token": question_token,
+            "stats": {"correct_24h": correct_attempts, "total_24h": total_attempts},
+        }
+    )
+
+
+@app.route("/get_video_content")
+def get_video_content():
+    """Streams the video based on the token passed in the query string."""
+    question_token = request.args.get("token")
+
+    if not question_token:
+        return "Missing question token", 400
+
+    idx = session.get(question_token)
+
+    if idx is None:
+        return "Invalid or expired question token", 400
+
+    if idx >= len(PROMPTS):
+        return "Internal prompt index out of bounds.", 500
+
+    prompt = PROMPTS[idx]
+    filename = get_video_filename(prompt["text"])
+    file_path = os.path.join(VIDEO_FOLDER, filename)
+
+    if not os.path.exists(file_path):
+        return "Video file not found on server", 404
+
+    response = make_response(
+        send_file(
+            file_path,
+            mimetype="video/mp4",
+            download_name="challenge.mp4",
+            as_attachment=False,
+        )
+    )
+
+    response.headers["Cache-Control"] = "no-store, no-cache, must-revalidate, max-age=0"
+    response.headers["Pragma"] = "no-cache"
+
+    return response
+
+
+@app.route("/submit_answer", methods=["POST"])
+def submit_answer():
+    data = request.json
+    user_answer = data.get("answer", "").lower()
+    user_ip = request.remote_addr
+    question_token = data.get("question_token")
+
+    if not question_token:
+        return jsonify({"error": "Missing question token on submit"}), 400
+
+    internal_index = session.get(question_token)
+
+    if internal_index is None:
+        return jsonify({"error": "Invalid or expired question token"}), 400
+
+    if internal_index >= len(PROMPTS):
+        return jsonify({"error": "Internal prompt index out of bounds."}), 500
+
+    target_data = PROMPTS[internal_index]
+    required_keywords = target_data["keywords"]
+
+    is_correct = all(keyword in user_answer for keyword in required_keywords)
+
+    conn = get_db()
+    cursor = conn.cursor()
+    cursor.execute(
+        """
+        INSERT INTO attempts (ip_address, question_index, is_correct)
+        VALUES (?, ?, ?)
+    """,
+        (user_ip, internal_index, is_correct),
+    )
+    conn.commit()
+    conn.close()
+
+    session.pop("current_question_token", None)
+    session.pop(question_token, None)
+
+    return jsonify(
+        {
+            "correct": is_correct,
+            "correct_answer": target_data["text"] if not is_correct else None,
+        }
+    )
+
+
+@app.route("/avg_colour", methods=["POST"])
 def avg_colour():
-    file = request.files['frame']
+    if "frame" not in request.files:
+        return jsonify({"colour": "#000000"})
+
+    file = request.files["frame"]
     file_bytes = np.frombuffer(file.read(), np.uint8)
     img = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)
 
-    # Compute average colour
-    avg_colour = cv2.mean(img)[:3]  # BGR
-    avg_colour_hex = '#{:02x}{:02x}{:02x}'.format(
+    if img is None:
+        return jsonify({"colour": "#000000"})
+
+    avg_colour = cv2.mean(img)[:3]
+    avg_colour_hex = "#{:02x}{:02x}{:02x}".format(
         int(avg_colour[2]), int(avg_colour[1]), int(avg_colour[0])
     )
     return jsonify({"colour": avg_colour_hex})
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     app.run(debug=True, port=8000)
diff --git a/index.html b/index.html
new file mode 100644
index 0000000..6cf3c2c
--- /dev/null
+++ b/index.html
@@ -0,0 +1,179 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <meta charset="UTF-8" />
+    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
+    <title>Signs of Inclusivity</title>
+    <style>
+      #colourBox {
+        width: 200px;
+        height: 200px;
+        border: 2px solid black;
+        margin-top: 20px;
+      }
+    </style>
+    <link rel="stylesheet" href="https://use.typekit.net/qtu0dlz.css" />
+    <link
+      rel="stylesheet"
+      href="{{ url_for('static', filename='style.css') }}"
+    />
+  </head>
+  <body>
+    <h1 class="title">Signs of Inclusivity</h1>
+
+    <div class="tabContainer">
+      <div class="tabsList" role="tablist">
+        <button
+          class="tab"
+          role="tab"
+          aria-selected="false"
+          aria-controls="learning-panel"
+          id="learning-tab"
+          tabindex="-1"
+        >
+          Learning Mode
+        </button>
+        <button
+          class="tab active"
+          role="tab"
+          aria-selected="true"
+          aria-controls="translator-panel"
+          id="translator-tab"
+          tabindex="0"
+        >
+          Real-Time Translator
+        </button>
+        <span class="tabIndicator"></span>
+      </div>
+    </div>
+
+    <section
+      class="tabPanel"
+      id="learning-panel"
+      role="tabpanel"
+      aria-labelledby="learning-tab"
+    >
+      <p class="learningComponent" id="statsDisplay">
+        Your score (last 24 hours): Loading...
+      </p>
+
+      <p class="learningComponent">What sign is being shown?</p>
+
+      <video class="video learningComponent" id="quizVideo" playsinline autoplay loop muted></video>
+
+      <div class="inputWrapper learningComponent">
+        <input
+          class="inputControl"
+          id="answer"
+          type="text"
+          placeholder="Type keywords (e.g., ”you help”)"
+          autocomplete="off"
+        />
+        <button class="button" id="submitAnswer">Submit</button>
+        <button
+          class="button"
+          id="nextQuestion"
+          style="display: none"
+        >
+          Next Sign
+        </button>
+      </div>
+
+      <p class="learningText learningComponent" id="feedbackMessage"></p>
+    </section>
+
+    <section
+      class="tabPanel active"
+      id="translator-panel"
+      role="tabpanel"
+      aria-labelledby="translator-tab"
+    >
+      <video class="video" id="localVideo" autoplay muted></video>
+      <div id="colourBox"></div>
+    </section>
+
+    <script src="{{ url_for('static', filename='tabs.js') }}"></script>
+    <script src="{{ url_for('static', filename='quiz.js') }}"></script>
+    <script>
+      let videoStream = null;
+      const video = document.getElementById("localVideo");
+      const canvas = document.createElement("canvas");
+      const ctx = canvas.getContext("2d");
+      let animationId = null;
+
+      async function startCamera() {
+        if (!videoStream) {
+          try {
+            videoStream = await navigator.mediaDevices.getUserMedia({
+              video: true,
+              audio: false,
+            });
+            video.srcObject = videoStream;
+            renderFrame();
+          } catch (err) {
+            console.error("Error accessing camera:", err);
+          }
+        }
+      }
+
+      function stopCamera() {
+        if (videoStream) {
+          videoStream.getTracks().forEach((track) => track.stop());
+          videoStream = null;
+        }
+        if (animationId) {
+          cancelAnimationFrame(animationId);
+          animationId = null;
+        }
+        video.srcObject = null;
+      }
+
+      async function renderFrame() {
+        if (!videoStream) return;
+
+        canvas.width = video.videoWidth;
+        canvas.height = video.videoHeight;
+        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
+
+        canvas.toBlob(async (blob) => {
+          const formData = new FormData();
+          formData.append("frame", blob, "frame.jpg");
+
+          try {
+            const res = await fetch("/avg_colour", {
+              method: "POST",
+              body: formData,
+            });
+            const data = await res.json();
+            document.getElementById("colourBox").style.backgroundColor =
+              data.colour;
+          } catch (err) {
+            console.error("Error sending frame:", err);
+          }
+        }, "image/jpeg");
+
+        animationId = requestAnimationFrame(renderFrame);
+      }
+
+      const translatorPanel = document.getElementById("translator-panel");
+
+      const observer = new MutationObserver(() => {
+        const isActive = translatorPanel.classList.contains("active");
+        if (isActive) {
+          startCamera();
+        } else {
+          stopCamera();
+        }
+      });
+
+      observer.observe(translatorPanel, {
+        attributes: true,
+        attributeFilter: ["class"],
+      });
+
+      if (translatorPanel.classList.contains("active")) {
+        startCamera();
+      }
+    </script>
+  </body>
+</html>
